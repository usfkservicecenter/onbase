<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>OnBase USAG Humphreys 건물 지도</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin />
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; }
    .building-label {
      color: #6b7280;       /* 라이트 맵에서 잘 보이는 회색 */
      font-size: 10px;      /* 요청: 10px */
      font-weight: 700;
      text-shadow: 1px 1px 2px #fff;
      white-space: nowrap;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin></script>
  <script>
    // ===== 게이트 좌표 (maxBounds 계산용) =====
    const gates = [
      { name: "Millet Gate (도두리)",  lat: 36.95819961, lon: 127.04428911 },
      { name: "Yoon Gate (윤)",       lat: 36.96894099, lon: 127.03556648 },
      { name: "Charlton Gate (함정리)", lat: 36.96366,    lon: 127.05111 }
    ];

    // bounds 계산 (+ 여유)
    const padDeg = 0.002;
    const lats = gates.map(g => g.lat), lons = gates.map(g => g.lon);
    const minLat = Math.min(...lats) - padDeg, maxLat = Math.max(...lats) + padDeg;
    const minLon = Math.min(...lons) - padDeg, maxLon = Math.max(...lons) + padDeg;
    const gateBounds = L.latLngBounds([[minLat, minLon],[maxLat, maxLon]]);

    // ===== 지도 (라이트 타일) =====
    const map = L.map('map', {
      zoomControl: true,
      scrollWheelZoom: true,   // 휠/트랙패드 줌 허용
      touchZoom: true,         // 터치 핀치줌 허용
      dragging: true,          // 드래그 허용
      doubleClickZoom: true
    });

    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
      attribution: '&copy; OpenStreetMap & CARTO',
      subdomains: 'abcd',
      maxZoom: 19
    }).addTo(map);

    map.setMaxBounds(gateBounds);
    map.fitBounds(gateBounds);
    // ★ panInsideBounds 강제 호출 제거 (스크롤 문제 원인 가능성)

    // (옵션) 게이트 점표시
    gates.forEach(g => {
      L.circleMarker([g.lat, g.lon], { radius: 4 }).addTo(map).bindTooltip(g.name);
    });

    // ===== 라벨 표시 제어 =====
    const buildingMarkers = [];
    const LABEL_ZOOM = 15; // 요청: 15부터 보이기

    function updateBuildingLabels() {
      const zoom = map.getZoom();
      buildingMarkers.forEach(m => {
        const onMap = map.hasLayer(m);
        if (zoom >= LABEL_ZOOM && !onMap) m.addTo(map);
        if (zoom <  LABEL_ZOOM && onMap)  map.removeLayer(m);
      });
    }
    map.on('zoomend', updateBuildingLabels);

    // ===== 좌표 로드: addr:housenumber 우선 표시 =====
    fetch('./buildings.json')
      .then(res => res.json())
      .then(buildings => {
        buildings.forEach(b => {
          const lat = b.lat ?? b.y;
          const lon = b.lon ?? b.x;
          if (lat == null || lon == null) return;

          // 라벨 텍스트: addr:housenumber 우선, 없으면 name
          const labelText =
            (b["addr:housenumber"] && String(b["addr:housenumber"]).trim()) ||
            (b.name && String(b.name).trim()) ||
            "";

          if (!labelText) return;

          const marker = L.marker([lat, lon], {
            icon: L.divIcon({
              className: 'building-label',
              html: labelText,
              iconSize: [26, 12],
              iconAnchor: [13, 6]
            })
          });
          buildingMarkers.push(marker);
        });
        updateBuildingLabels(); // 초기 적용
      })
      .catch(err => console.error('건물 좌표 로드 실패:', err));

    // 보조: 모바일 환경에서 브라우저가 자동 비활성화했을 경우 강제 enable
    map.whenReady(() => {
      if (!map.options.scrollWheelZoom) map.scrollWheelZoom.enable();
      if (!map.options.touchZoom) map.touchZoom.enable();
      if (!map.options.dragging) map.dragging.enable();
    });
  </script>
</body>
</html>
